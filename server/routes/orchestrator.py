from fastapi import APIRouter, BackgroundTasks, Depends, Query, File, UploadFile, Form
from pydantic import BaseModel
from typing import Optional, Dict, Any
import logging
import json
from datetime import datetime
from controller.orchestrator_controller import get_orchestrator_controller
from schemas.workflow_schemas import WorkflowRequest, WorkflowResponse, WorkflowStatus
from middleware.auth import get_current_user

logger = logging.getLogger(__name__)
router = APIRouter()

# Get controller instance
orchestrator_controller = get_orchestrator_controller()

@router.post("/workflow/invoice/start", response_model=WorkflowResponse)
async def start_invoice_workflow(
    background_tasks: BackgroundTasks,
    user_id: str = Form(...),
    contract_name: str = Form(...),
    max_attempts: int = Form(3),
    options: Optional[str] = Form(default='{}'),
    contract_file: Optional[UploadFile] = File(None),
    current_user: dict = Depends(get_current_user)
):
    """
    üöÄ Start a new agentic invoice processing workflow
    
    This endpoint initiates the complete agentic workflow by accepting form-data.
    Can handle both new contracts (with file upload) and existing contracts (without file).
    """
    import json
    
    # Handle file upload for new contracts or None for existing contracts
    file_bytes = None
    if contract_file and contract_file.filename != 'existing_contract.pdf':
        file_bytes = await contract_file.read()
    
    try:
        options_dict = json.loads(options)
    except json.JSONDecodeError:
        options_dict = {}

    request = WorkflowRequest(
        user_id=user_id,
        contract_name=contract_name,
        contract_file=file_bytes,
        max_attempts=max_attempts,
        options=options_dict
    )

    logger.info(f"üéØ API: Starting agentic workflow - User: {request.user_id}, Contract: {request.contract_name}")
    
    # Ensure user can only start workflows for themselves (unless admin)
    if not current_user.get("is_admin", False):
        request.user_id = current_user["user_id"]
    
    return await orchestrator_controller.start_invoice_workflow(request, background_tasks)


class StartAgenticWorkflowRequest(BaseModel):
    user_id: str
    contract_name: str
    contract_path: Optional[str] = None
    max_attempts: int = 3
    options: Optional[Dict[str, Any]] = None

@router.post("/workflow/invoice/start-for-contract", response_model=WorkflowResponse)
async def start_agentic_workflow_for_existing_contract(
    request: StartAgenticWorkflowRequest,
    background_tasks: BackgroundTasks,
    current_user: dict = Depends(get_current_user)
):
    """
    üöÄ Start agentic workflow for existing contract
    
    This endpoint starts the agentic invoice processing workflow for a contract
    that's already uploaded/processed in the system.
    """
    options = request.options or {}

    logger.info(f"üéØ API: Starting agentic workflow for existing contract - User: {request.user_id}, Contract: {request.contract_name}")
    
    # Ensure user can only start workflows for themselves (unless admin)
    user_id = request.user_id
    if not current_user.get("is_admin", False):
        user_id = current_user["user_id"]
    
    # For existing contracts, we can pass None as contract_file since the contract
    # is already processed/available in the system
    workflow_request = WorkflowRequest(
        user_id=user_id,
        contract_name=request.contract_name,
        contract_file=None,  # Will be handled differently for existing contracts
        max_attempts=request.max_attempts,
        options={**options, "existing_contract": True, "contract_path": request.contract_path}
    )
    
    return await orchestrator_controller.start_invoice_workflow(workflow_request, background_tasks)




@router.get("/workflow/{workflow_id}/invoice", response_model=Dict[str, Any])
async def get_workflow_invoice_data(
    workflow_id: str,
    current_user: dict = Depends(get_current_user)
):
    """
    üìÑ Get the final generated invoice JSON data from a completed workflow
    
    Returns the corrected and finalized invoice JSON generated by the correction agent.
    Only available for completed workflows.
    """
    logger.info(f"üìÑ API: Getting final invoice data - ID: {workflow_id}, User: {current_user['user_id']}")
    
    # Get the workflow state from active workflows
    workflow_info = orchestrator_controller.orchestrator_service.active_workflows.get(workflow_id)
    
    if not workflow_info:
        return {
            "error": "Workflow not found",
            "workflow_id": workflow_id,
            "message": "Workflow may have been completed and cleaned up, or the ID is invalid"
        }
    
    workflow_state = workflow_info.get("state", {})
    
    # Check if workflow has final invoice data
    final_invoice_json = workflow_state.get("final_invoice_json")
    correction_completed = workflow_state.get("correction_completed", False)
    
    if not final_invoice_json:
        return {
            "error": "Final invoice not yet generated",
            "workflow_id": workflow_id,
            "current_status": workflow_state.get("processing_status"),
            "current_agent": workflow_state.get("current_agent"),
            "correction_completed": correction_completed,
            "message": "Workflow may still be in progress or failed before invoice generation"
        }
    
    return {
        "workflow_id": workflow_id,
        "final_invoice_json": final_invoice_json,
        "correction_completed": correction_completed,
        "processing_status": workflow_state.get("processing_status"),
        "quality_score": workflow_state.get("quality_score", 0.0),
        "confidence_level": workflow_state.get("confidence_level", 0.0),
        "generated_at": workflow_state.get("last_updated_at"),
        "metadata": {
            "contract_name": workflow_state.get("contract_name"),
            "user_id": workflow_state.get("user_id"),
            "attempt_count": workflow_state.get("attempt_count", 0)
        }
    }

@router.get("/workflow/{workflow_id}/ui-template", response_model=Dict[str, Any])
async def get_workflow_ui_template(
    workflow_id: str,
    current_user: dict = Depends(get_current_user)
):
    """
    üé® Get the generated professional invoice UI template from a completed workflow
    
    Returns the HTML/CSS invoice template generated by the UI Invoice Generator agent.
    Only available for completed workflows.
    """
    logger.info(f"üé® API: Getting UI template - ID: {workflow_id}, User: {current_user['user_id']}")
    
    # Get the workflow state from active workflows
    workflow_info = orchestrator_controller.orchestrator_service.active_workflows.get(workflow_id)
    
    if not workflow_info:
        return {
            "error": "Workflow not found",
            "workflow_id": workflow_id,
            "message": "Workflow may have been completed and cleaned up, or the ID is invalid"
        }
    
    workflow_state = workflow_info.get("state", {})
    
    # Check if workflow has UI template
    ui_template = workflow_state.get("ui_invoice_template")
    
    if not ui_template:
        return {
            "error": "UI template not yet generated",
            "workflow_id": workflow_id,
            "current_status": workflow_state.get("processing_status"),
            "current_agent": workflow_state.get("current_agent"),
            "message": "Workflow may still be in progress or failed before UI template generation"
        }
    
    return {
        "workflow_id": workflow_id,
        "ui_template": ui_template,
        "processing_status": workflow_state.get("processing_status"),
        "quality_score": workflow_state.get("quality_score", 0.0),
        "confidence_level": workflow_state.get("confidence_level", 0.0),
        "workflow_completed": workflow_state.get("workflow_completed", False),
        "metadata": {
            "contract_name": workflow_state.get("contract_name"),
            "user_id": workflow_state.get("user_id"),
            "attempt_count": workflow_state.get("attempt_count", 0)
        }
    }

@router.get("/workflow/{workflow_id}/status", response_model=WorkflowStatus)
async def get_workflow_status(
    workflow_id: str,
    current_user: dict = Depends(get_current_user)
):
    """
    üîç Get the current status and progress of a workflow
    
    Returns detailed information about:
    - Current processing stage and agent
    - Progress percentage (0-100%)
    - Quality scores and confidence levels
    - Any errors or retry attempts
    - Estimated completion time
    """
    logger.info(f"üìä API: Getting workflow status - ID: {workflow_id}, User: {current_user['user_id']}")
    
    status = await orchestrator_controller.get_workflow_status(workflow_id)
    
    # Security check - users can only view their own workflows (unless admin)
    if not current_user.get("is_admin", False):
        # Would need to add user check here based on workflow owner
        pass
    
    return status

@router.delete("/workflow/{workflow_id}/cancel")
async def cancel_workflow(
    workflow_id: str,
    current_user: dict = Depends(get_current_user)
):
    """
    üõë Cancel a running workflow
    
    Gracefully stops the workflow execution and cleans up resources.
    Only the workflow owner or admin can cancel a workflow.
    """
    logger.info(f"üõë API: Cancelling workflow - ID: {workflow_id}, User: {current_user['user_id']}")
    
    # Security check would go here
    
    return await orchestrator_controller.cancel_workflow(workflow_id)

@router.get("/workflows/active")
async def list_active_workflows(
    user_id: Optional[str] = Query(None, description="Filter by user ID"),
    current_user: dict = Depends(get_current_user)
):
    """
    üìã List all active workflows
    
    Returns a list of currently running or recently completed workflows.
    Regular users can only see their own workflows, admins can see all.
    
    Query Parameters:
    - user_id: Filter workflows by specific user (admin only)
    """
    logger.info(f"üìã API: Listing workflows - Requester: {current_user['user_id']}, Filter: {user_id or 'none'}")
    
    # Security: Non-admin users can only see their own workflows
    if not current_user.get("is_admin", False):
        user_id = current_user["user_id"]
    
    return await orchestrator_controller.list_active_workflows(user_id)

@router.get("/workflow/health")
async def orchestrator_health_check():
    """
    üíö Health check endpoint for the orchestrator system
    
    Returns system health status and basic metrics about:
    - Active workflows count
    - System readiness
    - Available resources
    """
    logger.info("üíö API: Health check requested")
    
    try:
        orchestrator_service = orchestrator_controller.orchestrator_service
        active_count = len(orchestrator_service.active_workflows)
        
        return {
            "status": "healthy",
            "message": "Agentic orchestrator is running",
            "active_workflows": active_count,
            "system_ready": True,
            "version": "1.0.0",
            "features": [
                "Multi-agent orchestration",
                "Feedback loops & learning",
                "Quality assurance gates", 
                "Smart error recovery",
                "Real-time progress tracking",
                "LangGraph workflow engine"
            ]
        }
        
    except Exception as e:
        logger.error(f"‚ùå API: Health check failed: {str(e)}")
        return {
            "status": "unhealthy",
            "message": f"System error: {str(e)}",
            "system_ready": False
        }

@router.post("/workflow/test")
async def test_orchestrator_workflow():
    """
    üß™ Test endpoint for development and debugging
    
    Creates a simple test workflow to verify the system is working correctly.
    This endpoint is for development purposes only.
    """
    logger.info("üß™ API: Test workflow requested")
    
    test_request = WorkflowRequest(
        user_id="test_user_123",
        contract_file="test_contract.pdf",
        contract_name="Test Rental Agreement",
        max_attempts=2,
        options={"test_mode": True}
    )
    
    try:
        from fastapi import BackgroundTasks
        background_tasks = BackgroundTasks()
        
        # Create a minimal test user context
        test_user = {"user_id": "test_user_123", "is_admin": True}
        
        response = await orchestrator_controller.start_invoice_workflow(test_request, background_tasks)
        
        return {
            "test_status": "success",
            "workflow_id": response.workflow_id,
            "message": "Test workflow created successfully",
            "response": response.model_dump()
        }
        
    except Exception as e:
        logger.error(f"‚ùå API: Test workflow failed: {str(e)}")
        return {
            "test_status": "failed",
            "error": str(e),
            "message": "Test workflow creation failed"
        }
